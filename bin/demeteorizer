#!/usr/bin/env node

const Path = require('path');
const Program = require('commander');

const Build = require('../lib/build');
const UpdatePackage = require('../lib/update-package');

Program
  .version(require('../package.json').version)
  .option(
    '-o, --output <path>',
    'Output folder for converted application. Defaults to ./.demeteorized.')
  .option(
    '-r, --release <version>',
    'The Meteor version. Defaults to latest installed.')
  .option(
    '-t, --tarball <path>',
    'Output tarball path. If specified, creates a tar.gz of demeteorized application instead of directory.')
  .option(
    '-a, --app_name <name>',
    'Value to put in the package.json name field. Defaults to the current directory name.')
  .option(
    '-j, --json <json>',
    'JSON data to be merged into the generated package.json')
  .option(
    '-d, --debug',
    'Bundle in debug mode (don\'t minify, etc).', false)
  .parse(process.argv);

Program.output = Program.output || Path.join(process.cwd(), '.demeteorized');

if (Program.release) {
  console.log('Release:', Program.release);
}

try {
  Program.json = JSON.parse(Program.json);
} catch(e) {
  Program.json = {};
}

var options = {
  appName: Program.app_name,
  debug: Program.debug,
  input: process.cwd(),
  directory: Program.output,
  release: Program.release,
  tarball: Program.tarball,
  json: Program.json
};

Build(options, function (err) {
  if (err) {
    console.error(err.message);
    return process.exit(1);
  }

  UpdatePackage(options, function (err) {
    if (err) {
      console.error(err.message);
      return process.exit(1);
    }

    console.log('Demeteorization complete.');
  });
});
